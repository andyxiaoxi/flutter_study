//1,如何设计一个封装网络库
//2,请求和响应
//3,支持不同的响应体
//4,统一处理所有的网络请求
//5,支持不同的请求，下载，post,get,put,上传
//6,动态配置请求头
//7,支持数据安全请求
//8,取消网络请求
//9,https 和 http 支持
//10,多个网络请求，token过期问题 或者 自动调用登录

//目前，遇到的问题
//----------------------------
//1,Dio 对象是不是需要设置成单例

//2,怎么设置类的构成啊啊啊啊啊

//3,可能使用其他网络库，并不限定是Dio

// 请求发送类

// 请求配置类

// 请求类 ，响应类

// http配置类，对象是否需要设置成单例，它可能采用新的？

import 'package:flutter/foundation.dart';
import 'package:handclick/network/http_config.dart';
import 'package:handclick/network/response/data_parse.dart';
import 'response/response.dart';
import 'request/request.dart';

///为啥设置为抽象类，因为用户可能基于Dio ,也可能是其他库
abstract class HttpClient {
  //http配置类
  HttpConfig httpConfig;

  HttpClient(this.httpConfig);

  //未来会设置，同步发送，异步发送

  Future<Response<T>> send<T extends DataParse>(Request request);

  void upload();

  void download();

  //上面的方法，是请求的一些基本方法
  //-------------------------------------------
  //我也不知道为啥，要添加下面的方法
  //下面的方法，用来读取http的配置信息，然后给底层库设置
}

//第一步
//http或者其他协议， 请求对像 和 响应对象之间的关系？
//思考： 一对一，我发个请求，服务器就会返回响应的响应对象

//第二步
//产生上面问题的原因是：  我服务返回的数据-------怎么转成对应 类（可读对象）
//因此我需要拿到，具体响应对象的类型，怎么拿呢？
//答：1, 请求对象 ， 1,有响应对象的{字段} 2，有响应对象的方法{resp==create()} 3，具有响应类型的泛型请求对象{Request<T(响应对象)>}
//   讨论：上面3种方式的可行性
//   泛型方式： Request<T(响应对象)> ，泛型类的特点：有对应泛型字段，T resp, 或者泛型方法  T  fun();
//   字段方式： 感觉就是请求对象多了一个响应字段（感觉不是很合理）
//   响应对象的方法： 这里就感觉不是很合理，请求对像，含有一个生成响应的对象的方法（....这里不确定是否我的理解对吗）

//   2, send方法中描述 {1,参数 2,泛型方法}
//   讨论：这2种方式可行性
//   参数方式： 那么需要传递一个具体响应对象，需要构造一个
//   泛型方法： send<T> ---------------【√】

//第三步
//知道了响应对象具体类型， 现在需要把响应原始数据，转成 具体类型
//那么这个转换，该怎么做， 转换成具体的实体类（不管是pb,还是json,按道理实体对象是同一个吧，理解有问题吗？）
// 什么方式  转换成泛型 T 呢  T resp = (什么方式转换)，是toJson,还是toPb,需要有人告诉我，采用什么方法转换;
//因此，1，可能在某个配置，此次通信的方式，2，send方法里参数 3，泛型T对象有含有通信参数（放在这里合适吗）4，请求对象里含有此次通信格式
//假设知道采用json格式， 就调用 T().toJson(响应原始数据);
